# 🚀 多线程抓取功能实现说明

## 📋 功能概述

**多线程抓取**是将原来的**顺序处理**改为**并发处理**，让程序可以同时处理多个模特，从而大幅提升处理速度。

---

## 🔄 核心改动

### **改动位置**: `core/core.py` 主程序

### **改动内容**:

#### 1. **导入多线程库**
```python
# 在文件开头添加
from concurrent.futures import ThreadPoolExecutor, as_completed
```

#### 2. **提取处理逻辑为独立函数**
将原来在循环中的模特处理逻辑提取为独立函数：
```python
def process_single_model(model_info, config, logger, missing_logger, 
                        countries_dir, cache_dir, running_flag):
    """处理单个模特的函数（可以被多线程调用）"""
    # 包含原来循环中的所有处理逻辑
    # 1. 提取本地视频
    # 2. 抓取在线视频
    # 3. 比对缺失
    # 4. 保存报告
```

#### 3. **使用线程池并发处理**
将原来的 `for` 循环改为线程池：

**原来（顺序处理）**:
```python
# 一个一个处理，速度慢
for i, (model_name, folder, original_dir, country) in enumerate(local_matches, 1):
    # 处理模特 1
    # 处理模特 2
    # 处理模特 3
    # ...
```

**改为（并发处理）**:
```python
# 同时处理多个模特，速度快
with ThreadPoolExecutor(max_workers=3) as executor:
    futures = []
    for model_info in local_matches:
        future = executor.submit(process_single_model, model_info, config, ...)
        futures.append(future)
    
    # 收集结果
    for future in as_completed(futures):
        result = future.result()
```

---

## 📊 效果对比

### **处理方式对比**

| 对比项 | 顺序处理（原来） | 并发处理（新增） |
|--------|----------------|----------------|
| **处理方式** | 一个接一个 | 同时处理多个 |
| **CPU 利用率** | 低（单线程） | 高（多线程） |
| **等待时间** | 长（累加） | 短（重叠） |
| **总耗时** | 100% | 25-33% |

### **时间对比示例**

假设处理 1 个模特需要 2 分钟：

| 模特数量 | 顺序处理耗时 | 多线程处理耗时（3线程） | 提升 |
|---------|------------|---------------------|------|
| 10 个 | 20 分钟 | 7 分钟 | ⬇️ 65% |
| 30 个 | 60 分钟 | 20 分钟 | ⬇️ 67% |
| 100 个 | 200 分钟 | 67 分钟 | ⬇️ 67% |

---

## 🎯 关键参数

### **max_workers（线程数量）**

在配置文件 `config.yaml` 中设置：

```yaml
performance:
  max_workers: 3  # 同时处理 3 个模特
```

**推荐值**:
- **保守**: `max_workers: 2` - 安全稳定
- **推荐**: `max_workers: 3` - 速度与稳定平衡 ⭐
- **激进**: `max_workers: 5` - 速度最快，但可能被反爬虫

---

## 🔧 技术实现细节

### **1. 线程安全**
多个线程同时运行，需要确保：
- ✅ 每个线程有独立的 Selenium 实例
- ✅ 日志写入使用锁保护
- ✅ 缓存文件读写互不干扰

### **2. 资源管理**
```python
# 每个线程独立的 Selenium 浏览器
selenium = SeleniumHelper(config)
selenium.driver = selenium.setup_driver()

# 处理完成后关闭
selenium.close()
```

### **3. 错误处理**
```python
try:
    result = future.result()
except Exception as e:
    logger.error(f"模特处理失败: {e}")
    # 不影响其他线程继续运行
```

---

## 💡 使用示例

### **场景 1: 处理 10 个模特**

**顺序处理**:
```
模特1 [====================] 2分钟
模特2 [====================] 2分钟
模特3 [====================] 2分钟
...
总计: 20 分钟
```

**多线程处理（3线程）**:
```
线程1: 模特1 [======] 模特4 [======] 模特7 [======] 模特10
线程2: 模特2 [======] 模特5 [======] 模特8 [======]
线程3: 模特3 [======] 模特6 [======] 模特9 [======]
总计: 约 7 分钟
```

---

## ⚠️ 注意事项

### **1. 代理限制**
如果使用代理，注意：
- 某些代理有连接数限制
- 建议使用支持多连接的代理

### **2. 反爬虫**
并发过高可能触发：
- IP 封禁
- 验证码检查

**解决方案**:
- 降低 `max_workers` 值
- 增加延时配置

### **3. 内存占用**
每个线程会占用：
- 1 个 Chrome 浏览器实例（约 200-300 MB）
- 建议不超过 5 个线程

---

## 📈 性能优化建议

### **1. 根据硬件调整线程数**
```yaml
# 4核CPU
max_workers: 3

# 8核CPU  
max_workers: 5

# 16核CPU
max_workers: 8
```

### **2. 监控 CPU 和内存**
- CPU 使用率 > 80%: 降低线程数
- 内存不足: 降低线程数

### **3. 网络带宽**
- 良好网络: 可以增加线程数
- 差网络: 降低线程数避免超时

---

## 🔍 日志示例

**多线程运行时的日志**:
```
2026-02-09 10:00:00 | INFO | 🚀 启动多线程处理模式（3 个工作线程）
2026-02-09 10:00:01 | INFO | [线程-1] 处理模特: Alice (1/10)
2026-02-09 10:00:01 | INFO | [线程-2] 处理模特: Bob (2/10)
2026-02-09 10:00:01 | INFO | [线程-3] 处理模特: Carol (3/10)
2026-02-09 10:02:15 | INFO | [线程-1] ✅ Alice 处理完成
2026-02-09 10:02:16 | INFO | [线程-1] 处理模特: David (4/10)
2026-02-09 10:02:30 | INFO | [线程-2] ✅ Bob 处理完成
2026-02-09 10:02:31 | INFO | [线程-2] 处理模特: Eve (5/10)
...
```

---

## 📚 相关配置

### **config.yaml 完整配置**
```yaml
# 性能配置
performance:
  # 并发工作线程数（建议 2-5）
  max_workers: 3
  
  # 单个模特超时时间（秒）
  model_timeout: 600
  
  # 启用多线程模式
  enable_multithreading: true

# 延时配置（多线程模式下仍然有效）
delay_between_pages:
  min: 2.0
  max: 3.5
```

---

## ✅ 总结

### **核心改动**
1. 添加 `ThreadPoolExecutor` 多线程支持
2. 提取处理逻辑为独立函数
3. 添加配置选项控制线程数

### **主要优势**
- ⚡ 速度提升 3-5 倍
- 💪 充分利用 CPU 多核
- 🎯 可配置并发数量
- 🔒 线程安全设计

### **适用场景**
- ✅ 大批量模特处理（>10个）
- ✅ 网络稳定的环境
- ✅ 多核 CPU 机器
- ⚠️ 注意代理和反爬虫限制

---

**问题咨询**: 如有疑问，请参考 `OPTIMIZATION_SUGGESTIONS.md` 中的 P1-1 章节
